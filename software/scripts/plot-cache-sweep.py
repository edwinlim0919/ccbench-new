# Generates plots from ccbench cache benchmarks based on arguments provided
#
# Arguments
#     arg1: workload name
#     arg2: job name
#     arg1: lower cutoff of range in bytes
#     arg2: upper cutoff of range in bytes
#
# Example Usage
#     plot-caches-br.py 32768 524288
import matplotlib
import matplotlib.pyplot as plt
import re
import sys
import statistics


result_dir = '../../results'
plot_dir = '../../plots'
result_file = '/run_result.csv'
full_plot_separate = '/full_plot_separate.pdf'
full_plot_together = '/full_plot_together.pdf'
range_plot_separate = '/range_plot_separate.pdf'
range_plot_together = '/range_plot_together.pdf'
configs = ['/direct-mapped', '/2-way-set-associative', '/4-way-set-associative', '/8-way-set-associative']
plt_coords = [[0, 0], [0, 1], [1, 0], [1, 1]]
plt_colors = ['red', 'blue', 'green', 'darkviolet']


# Parses .csv file generated by caches-br : caches
# Returns a list of tuples in the format (<AppSize>, <Time>)
def parse_caches(fdata):
    tuplelist = []
    AppSize_pattern = re.compile('AppSize:\[\d*\.*\d*\]')
    Time_pattern = re.compile('Time:\[\d*\.*\d*\]')

    for line in fdata.splitlines():
        AppSize_str = AppSize_pattern.findall(line)[0]
        Time_str = Time_pattern.findall(line)[0]
        AppSize = int(AppSize_str[9:len(AppSize_str)-1])
        Time = float(Time_str[6:len(Time_str)-1])
        tuplelist.append((AppSize, Time))

    return tuplelist


# Parses .csv file generated by strided-br : strided
# Returns a dictionary of tuple lists (one per stride) in the format (<AppSize>, <Time>, <AppStride>)
def parse_strided(fdata):
    stride_dict = {}
    AppSize_pattern = re.compile('AppSize:\[\d*\.*\d*\]')
    AppStride_pattern = re.compile('AppStride:\[\d*\.*\d*\]')
    Time_pattern = re.compile('Time:\[\d*\.*\d*\]')

    for line in fdata.splitlines():
        AppSize_str = AppSize_pattern.findall(line)[0]
        Time_str = Time_pattern.findall(line)[0]
        AppStride_str = AppStride_pattern.findall(line)[0]
        AppSize = int(AppSize_str[9:len(AppSize_str)-1])
        Time = float(Time_str[6:len(Time_str)-1])
        AppStride = int(AppStride_str[11:len(AppStride_str)-1])

        if AppStride in stride_dict.keys():
            stride_dict[AppStride].append((AppSize, Time))
        else:
            stride_dict[AppStride] = [(AppSize, Time)]

    return stride_dict

# Removes outliers from either caches
#def remove_outliers(tuplelist):
#    curr_AppSize = tuplelist[0][0]
#    curr_Times = []
#    tuplelist_cleaned = []

#    for i in range(len(tuplelist)):



# Removes outliers from data by recording median run result of each AppSize
def remove_outliers(AppSizes, Times):
    curr_AppSize = AppSizes[0]
    curr_Times = [Times[0]]
    AppSizes_cleaned = []
    Times_cleaned = []

    for i in range(len(AppSizes)-1):
        index = i+1

        if AppSizes[index] != curr_AppSize:
            # We saved all run results for a single AppSize, and now we record the median
            median = statistics.median(curr_Times)
            AppSizes_cleaned.append(curr_AppSize)
            Times_cleaned.append(median)
            curr_AppSize = AppSizes[index]
            curr_Times.clear()

        curr_Times.append(Times[index])

    # Last AppSize has not been recorded yet
    median = statistics.median(curr_Times)
    AppSizes_cleaned.append(curr_AppSize)
    Times_cleaned.append(median)

    return AppSizes_cleaned, Times_cleaned 


def remove_outliers_strided(stride_dict):
    for stride in stride_dict.keys():
        curr_AppSizes = []
        curr_Times = []
        
        for i in range(len(stride_dict[stride])):
            curr_AppSizes.append(stride_dict[stride][i][0])
            curr_Times.append(stride_dict[stride][i][1])
            
        curr_AppSizes_cleaned, curr_Times_cleaned = remove_outliers(curr_AppSizes, curr_Times)
        tuplelist = []

        for i in range(len(curr_AppSizes_cleaned)):
            tuplelist.append((curr_AppSizes_cleaned[i], curr_Times_cleaned[i]))

        stride_dict[stride] = tuplelist


# Generates individual graphs for different configurations
#     plt_range: a range (in bytes) over which to plot points
#     plt_name: specifies name of graph pdf
def plot_separate(plt_range, plt_name):
    plt.clf()
    figure, axis = plt.subplots(2, 2, sharex=True, sharey=True)
    figure.tight_layout(pad=3.0)
    plt.locator_params(axis='x', nbins=10)
    plt.locator_params(axis='y', nbins=10)
    plt.xlabel('AppSize (bytes)', fontsize=8)
    plt.ylabel('Cycles Per Iteration', fontsize=8)

    for i in range(len(configs)):
        config, plt_coord, plt_color = configs[i], plt_coords[i], plt_colors[i]

        fpath = result_dir + config + result_file
        f = open(fpath, 'r')
        fdata = f.read()
        f.close()
        AppSizes, Times = parse_caches(fdata)
        AppSizes_cleaned, Times_cleaned = remove_outliers(AppSizes, Times)

        # AppSizes specifies number of unsigned 32-bit ints, so multiply by 4 for bytes
        NumBytes = [size * 4 for size in AppSizes_cleaned]
        NumBytes_plt, Times_plt = [], []

        if len(plt_range) == 0:
            NumBytes_plt, Times_plt = NumBytes, Times_cleaned
        else:
            for i in range(len(NumBytes)):
                if NumBytes[i] >= plt_range[0] and NumBytes[i] <= plt_range[1]:
                    NumBytes_plt.append(NumBytes[i])
                    Times_plt.append(Times_cleaned[i])

        axis[plt_coord[0], plt_coord[1]].plot(NumBytes_plt, Times_plt, color=plt_color)
        axis[plt_coord[0], plt_coord[1]].set_title(config[1:], fontsize=8)

    plt.savefig(plot_dir + plt_name)


run_result_names = ['/2022-07-06--06-39-39-strided-br',
                    '/2022-07-06--14-28-25-strided-br',
                    '/2022-07-06--23-04-34-strided-br',
                    '/2022-07-07--07-40-38-strided-br',
                    '/2022-07-07--16-16-50-strided-br',
                    '/2022-07-08--00-52-58-strided-br']

strided_colors = ['red', 'blue', 'green', 'darkviolet', 'magenta']

plt_names = ['stride1',
             'stride4',
             'stride16',
             'stride64',
             'stride256']

def plot_all_strided(plt_range):
    for i in range(len(run_result_names)):
        fpath = '/home/centos/firesim/deploy/results-workload' + run_result_names[i] + '/strided-br-strided/run_result.csv'
        f = open(fpath, 'r')
        fdata = f.read()
        f.close()
        
        stride_dict = parse_strided(fdata)
        remove_outliers_strided(stride_dict)

        plt_path = '/home/centos/firesim' + run_result_names[i]
        plot_together_strided(stride_dict, plt_path)


def plot_together_strided(stride_dict, plt_name):
    plt.clf()
    plt.locator_params(axis='x', nbins=10)
    plt.locator_params(axis='y', nbins=10)
    plt.xlabel('AppSize (bytes)', fontsize=8)
    plt.ylabel('Time Per Iteration (ns)', fontsize=8)

    curr_AppSizes = []
    curr_Times = []
    for i in range(len(stride_dict[1])):
        curr_AppSizes.append(stride_dict[1][i][0])
        curr_Times.append(stride_dict[1][i][1])
    plt.plot(curr_AppSizes, curr_Times, color='red', label='stride1')

    curr_AppSizes = []
    curr_Times = []
    for i in range(len(stride_dict[4])):
        curr_AppSizes.append(stride_dict[4][i][0])
        curr_Times.append(stride_dict[4][i][1])
    plt.plot(curr_AppSizes, curr_Times, color='blue', label='stride4') 
        
    curr_AppSizes = []
    curr_Times = []
    for i in range(len(stride_dict[16])):
        curr_AppSizes.append(stride_dict[16][i][0])
        curr_Times.append(stride_dict[16][i][1])
    plt.plot(curr_AppSizes, curr_Times, color='green', label='stride16')

    curr_AppSizes = []
    curr_Times = []
    for i in range(len(stride_dict[64])):
        curr_AppSizes.append(stride_dict[64][i][0])
        curr_Times.append(stride_dict[64][i][1])
    plt.plot(curr_AppSizes, curr_Times, color='darkviolet', label='stride64')

    curr_AppSizes = []
    curr_Times = []
    for i in range(len(stride_dict[256])):
        curr_AppSizes.append(stride_dict[256][i][0])
        curr_Times.append(stride_dict[256][i][1])
    plt.plot(curr_AppSizes, curr_Times, color='magenta', label='stride256')

    plt.legend()
    plt.savefig(plt_name) 


# Generates a single graph containing all different configurations
#     plt_range: a range (in bytes) over which to plot points
#     plt_name: specifies name of graph pdf
def plot_together(plt_range, plt_name):
    plt.clf()
    plt.locator_params(axis='x', nbins=10)
    plt.locator_params(axis='y', nbins=10)
    plt.xlabel('AppSize (bytes)', fontsize=8)
    plt.ylabel('Cycles Per Iteration', fontsize=8)

    for i in range(len(configs)):
        config, plt_color = configs[i], plt_colors[i]

        fpath = result_dir + config + result_file
        f = open(fpath, 'r')
        fdata = f.read()
        f.close()
        AppSizes, Times = parse_caches(fdata)
        AppSizes_cleaned, Times_cleaned = remove_outliers(AppSizes, Times)    

        # AppSizes specifies number of unsigned 32-bit ints, so multiply by 4 for bytes
        NumBytes = [size * 4 for size in AppSizes_cleaned]
        NumBytes_plt, Times_plt = [], []

        if len(plt_range) == 0:
            NumBytes_plt, Times_plt = NumBytes, Times_cleaned
        else:
            for i in range(len(NumBytes)):
                if NumBytes[i] >= plt_range[0] and NumBytes[i] <= plt_range[1]:
                    NumBytes_plt.append(NumBytes[i])
                    Times_plt.append(Times_cleaned[i]) 
        
        plt.plot(NumBytes_plt, Times_plt, color=plt_color, label=config[1:])

    plt.legend()
    plt.savefig(plot_dir + plt_name)


#if len(sys.argv) != 3:
#    print("Incorrect number of arguments provided.")
#else:
    #plot_range = [int(sys.argv[1]), int(sys.argv[2])]
    #plot_separate(plot_range, range_plot_separate)
    #plot_together(plot_range, range_plot_together)
    #plot_separate([], full_plot_separate)
    #plot_together([], full_plot_together)

plot_all_strided([])
